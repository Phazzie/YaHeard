/** * ============================================================================= * @file +page.server.ts - MULTI-AI TRANSCRIPTION SERVER * ============================================================================= * * WHY THIS FILE EXISTS: * ===================== * This server-side code orchestrates the Multi-AI Transcription Consensus Engine. * It coordinates parallel processing across Whisper, AssemblyAI, and Gemini services, * then applies consensus algorithms to provide the most accurate transcription. * * @phazzie-status working * @last-regenerated 2025-08-29 15:30 UTC * @dependencies All AI service implementations and consensus engine * * ARCHITECTURAL ROLE: * =================== * 1. FORM HANDLING: Processes audio file uploads from users * 2. PARALLEL PROCESSING: Runs all AI services simultaneously * 3. CONSENSUS ENGINE: Applies algorithms to find best transcription * 4. ERROR HANDLING: Graceful degradation when services fail * 5. SECURITY: Server-side API key management * * REGENERATION RULES: * =================== * ✅ COMPLETE REGENERATION ALLOWED: This file can be rewritten * ✅ API INTEGRATION: Update when adding new AI services * ✅ CONSENSUS ALGORITHMS: Regenerate when improving accuracy * ✅ ERROR HANDLING: Update when services change error patterns */ // Define Actions type for SvelteKit form handlinginterface Actions {  [key: string]: (event: { request: Request }) => Promise<any>;}import type { AudioProcessor } from '../contracts/processors';import type { TranscriptionResult } from '../contracts/transcription';import { AssemblyAIProcessor } from '../implementations/assembly';import { DeepgramProcessor } from '../implementations/deepgram';import { ElevenLabsProcessor } from '../implementations/elevenlabs';import { WhisperProcessor } from '../implementations/whisper';import { GeminiService } from '../lib/services/gemini';// ========= REGENERATION BOUNDARY START: Rate Limiting =========// @phazzie: This section can be regenerated independently// @contract: Must prevent API abuse with configurable limits// @dependencies: None/** * SIMPLE RATE LIMITING - PREVENT API ABUSE * ========================================= *  * WHY THIS APPROACH: * ================== * - In-memory tracking (simple for single server) * - IP-based limits prevent individual abuse * - Configurable limits for different tiers * - Automatic cleanup prevents memory leaks *  * PRODUCTION CONSIDERATIONS: * ========================= * - For multi-server: use Redis or database * - Consider user accounts for higher limits * - Add exponential backoff for repeat offenders */interface RateLimitEntry {  count: number;  resetTime: number;  lastRequest: number;}// In-memory rate limit tracking (per IP)const rateLimitMap = new Map<string, RateLimitEntry>();// Rate limit configurationconst RATE_LIMIT_CONFIG = {  windowMs: 15 * 60 * 1000, // 15 minutes  maxRequests: 10, // 10 requests per 15 minutes per IP  cleanupIntervalMs: 60 * 1000 // Clean up every minute};// Cleanup old entries periodicallysetInterval(() => {  const now = Date.now();  rateLimitMap.forEach((entry, ip) => {    if (now > entry.resetTime) {      rateLimitMap.delete(ip);    }  });}, RATE_LIMIT_CONFIG.cleanupIntervalMs);/** * Check if IP has exceeded rate limit */function checkRateLimit(clientIP: string): { allowed: boolean; remaining: number; resetTime: number } {  const now = Date.now();  const entry = rateLimitMap.get(clientIP);  if (!entry || now > entry.resetTime) {    // New or expired entry    const newEntry: RateLimitEntry = {      count: 1,      resetTime: now + RATE_LIMIT_CONFIG.windowMs,      lastRequest: now    };    rateLimitMap.set(clientIP, newEntry);    return {      allowed: true,      remaining: RATE_LIMIT_CONFIG.maxRequests - 1,      resetTime: newEntry.resetTime    };  }  // Update existing entry  entry.count++;  entry.lastRequest = now;  const allowed = entry.count <= RATE_LIMIT_CONFIG.maxRequests;  const remaining = Math.max(0, RATE_LIMIT_CONFIG.maxRequests - entry.count);  return {    allowed,    remaining,    resetTime: entry.resetTime  };}/** * Get client IP address from request */function getClientIP(request: Request): string {  // Check various headers for real IP (for proxies/load balancers)  const forwarded = request.headers.get('x-forwarded-for');  if (forwarded) {    return forwarded.split(',')[0].trim();  }    const realIP = request.headers.get('x-real-ip');  if (realIP) {    return realIP;  }  // Fallback to a generic identifier  return 'unknown';}// ========= REGENERATION BOUNDARY END: Rate Limiting =========// ========= REGENERATION BOUNDARY START: Request Timeouts =========// @phazzie: This section can be regenerated independently// @contract: Must add timeout handling to prevent hanging requests// @dependencies: None/** * REQUEST TIMEOUT HANDLING - PREVENT HANGING REQUESTS * =================================================== *  * WHY THIS APPROACH: * ================== * - AI services can hang or take too long * - Users shouldn't wait indefinitely * - Server resources need protection * - Graceful degradation when services timeout *  * TIMEOUT CONFIGURATION: * ===================== * - Conservative timeout (45 seconds per service) * - Allows for file upload + processing time * - Logs timeouts for monitoring */const TIMEOUT_CONFIG = {  serviceTimeoutMs: 45000, // 45 seconds per AI service  uploadTimeoutMs: 30000   // 30 seconds for file upload};/** * Wraps a promise with timeout functionality */function withTimeout<T>(promise: Promise<T>, timeoutMs: number, serviceName: string): Promise<T> {  return new Promise((resolve, reject) => {    const timeoutId = setTimeout(() => {      reject(new Error(`${serviceName} request timed out after ${timeoutMs / 1000} seconds`));    }, timeoutMs);    promise      .then(result => {        clearTimeout(timeoutId);        resolve(result);      })      .catch(error => {        clearTimeout(timeoutId);        reject(error);      });  });}// ========= REGENERATION BOUNDARY END: Request Timeouts =========// ========= REGENERATION BOUNDARY START: Consensus Algorithm =========// @phazzie: This algorithm can be completely regenerated// @contract: Must take array of results and return consensus// @dependencies: TranscriptionResult interface/** * CONSENSUS ALGORITHM - WHY THIS APPROACH (FROM LESSONS LEARNED) * ============================================================= * * CURRENT APPROACH: Simple confidence-based selection * =================================================== * Why? Different AI services use different tokenization and punctuation * Word-by-word voting becomes unreliable due to these differences * Simple approach works better than complex algorithms in practice * * FUTURE REGENERATION OPPORTUNITIES: * ================================ * 1. SEMANTIC SIMILARITY: Use NLP to find meaning-based consensus * 2. WEIGHTED VOTING: Consider service reliability history * 3. HYBRID APPROACH: Combine confidence + semantic similarity * 4. SPEAKER DIARIZATION: Handle multiple speakers in consensus * 5. CONTEXT AWARE: Use domain knowledge for specialized content * * LESSONS LEARNED APPLICATION: * =========================== * - Simple algorithms often outperform complex ones * - Service diversity provides better accuracy than single service * - Parallel processing enables real-time consensus * - Graceful degradation handles service failures */interface ConsensusResult {  consensus: string;  allResults: TranscriptionResult[];  agreementPercentage: number;  processingTimeMs: number;}/** * Calculates consensus from multiple AI transcription results using enhanced algorithm *  * @param results - Array of transcription results from different AI services * @returns ConsensusResult with best transcription and agreement metrics *  * @description * Enhanced consensus algorithm that combines confidence scores with text similarity analysis. * Uses Jaccard similarity for word-level comparison and weights confidence (70%)  * with similarity to other results (30%) for optimal selection. *  * @example * ```typescript * const results = [whisperResult, assemblyResult, deepgramResult]; * const consensus = calculateConsensus(results); * console.log(consensus.consensus); // Best transcription text * console.log(consensus.agreementPercentage); // How much services agreed * ``` */function calculateConsensus(results: TranscriptionResult[]): ConsensusResult {  const successful = results.filter(r => r.text && r.text.trim().length > 0);  if (successful.length === 0) {    return {      consensus: '',      allResults: results,      agreementPercentage: 0,      processingTimeMs: Math.max(...results.map(r => r.processingTimeMs || 0)),    };  }  // ENHANCED CONSENSUS WITH TEXT SIMILARITY ANALYSIS  // ================================================  // Combines confidence scores with text similarity for better results  // Uses multiple approaches: word overlap, length similarity, and confidence  if (successful.length === 1) {    // Single result - return it directly    return {      consensus: successful[0].text,      allResults: results,      agreementPercentage: 100,      processingTimeMs: Math.max(...results.map(r => r.processingTimeMs || 0)),    };  }  // Calculate word-level similarity between transcriptions  function calculateTextSimilarity(text1: string, text2: string): number {    const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);    const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);        if (words1.length === 0 && words2.length === 0) return 1.0;    if (words1.length === 0 || words2.length === 0) return 0.0;        const set1 = new Set(words1);    const set2 = new Set(words2);    const intersection = new Set(Array.from(set1).filter(w => set2.has(w)));    const union = new Set([...Array.from(set1), ...Array.from(set2)]);        return intersection.size / union.size; // Jaccard similarity  }  // Score each result based on confidence and similarity to others  const scoredResults = successful.map(result => {    const confidence = result.confidence || 0;        // Calculate average similarity to all other results    const similarities = successful      .filter(other => other !== result)      .map(other => calculateTextSimilarity(result.text, other.text));        const avgSimilarity = similarities.length > 0       ? similarities.reduce((sum, sim) => sum + sim, 0) / similarities.length       : 0;        // Combined score: 70% confidence + 30% similarity to others    const combinedScore = (confidence * 0.7) + (avgSimilarity * 0.3);        return {      result,      confidence,      avgSimilarity,      combinedScore    };  });  // Sort by combined score and select the best  scoredResults.sort((a, b) => b.combinedScore - a.combinedScore);  const bestResult = scoredResults[0].result;  // Calculate agreement percentage based on text similarity  const similarities = successful.map(result =>     calculateTextSimilarity(bestResult.text, result.text)  );  const agreementPercentage = Math.round(    (similarities.reduce((sum, sim) => sum + sim, 0) / similarities.length) * 100  );  return {    consensus: bestResult.text,    allResults: results,    agreementPercentage,    processingTimeMs: Math.max(...results.map(r => r.processingTimeMs || 0)),  };}// ========= REGENERATION BOUNDARY END: Consensus Algorithm =========// ========= REGENERATION BOUNDARY START: Form Actions =========// @phazzie: This section can be regenerated independently// @contract: Must handle form submissions and return appropriate responses// @dependencies: AI service implementationsexport const actions: Actions = {  // Default action for form submissions  default: async (event: { request: Request }) => {    const { request } = event;    // Apply rate limiting    const clientIP = getClientIP(request);    const rateLimitResult = checkRateLimit(clientIP);        if (!rateLimitResult.allowed) {      const resetTime = new Date(rateLimitResult.resetTime).toLocaleTimeString();      return {        success: false,        error: `Rate limit exceeded. You can make ${RATE_LIMIT_CONFIG.maxRequests} requests every ${RATE_LIMIT_CONFIG.windowMs / 60000} minutes. Try again after ${resetTime}.`      };    }    try {      const formData = await request.formData();      const audioFile = formData.get('audio') as File;      // WHY COMPREHENSIVE VALIDATION:      // ==============================      // Audio files can be large and malicious      // Validate early to prevent resource waste      // Provide clear error messages for regeneration      if (!audioFile || audioFile.size === 0) {        return {          success: false,          error: 'No audio file provided. Please select an audio file to transcribe.',        };      }      // WHY FILE SIZE LIMIT:      // ====================      // Prevent abuse and manage server resources      // 25MB is reasonable for most audio files      // Can be adjusted during regeneration      if (audioFile.size > 25 * 1024 * 1024) {        return {          success: false,          error: 'File too large. Maximum size is 25MB.',        };      }      // WHY MIME TYPE VALIDATION:      // =========================      // Security: Prevent non-audio file uploads      // User experience: Early feedback on unsupported files      // API compatibility: Ensure all services can process the file      const allowedMimeTypes = [        'audio/mpeg',        'audio/mp3',        'audio/wav',        'audio/wave',        'audio/x-wav',        'audio/mp4',        'audio/m4a',        'audio/aac',        'audio/ogg',        'audio/webm',        'audio/flac',      ];      if (!allowedMimeTypes.includes(audioFile.type)) {        return {          success: false,          error: `Unsupported file type: ${audioFile.type}. Please upload an audio file (MP3, WAV, M4A, etc.)`,        };      }      // WHY DEBUGGING INFO:      // ===================      // Show which file is being processed      // File validation completed - proceeding with transcription      // WHY ENVIRONMENT VARIABLE CONFIG:      // ================================      // API keys must be server-side for security      // Different services may have different keys      // Easy to configure per deployment environment      // Environment variable validation      const requiredEnvVars = [        'OPENAI_API_KEY',        'ASSEMBLYAI_API_KEY',        'GEMINI_API_KEY',        'DEEPGRAM_API_KEY',        'ELEVENLABS_API_KEY',      ];      const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);      if (missingVars.length > 0) {        // Log missing environment variables for debugging        return {          success: false,          error: `Missing required environment variables: ${missingVars.join(', ')}. Please check your .env file.`,        };      }      const openaiKey = process.env.OPENAI_API_KEY;      const assemblyKey = process.env.ASSEMBLYAI_API_KEY;      const geminiKey = process.env.GEMINI_API_KEY;      const deepgramKey = process.env.DEEPGRAM_API_KEY;      const elevenlabsKey = process.env.ELEVENLABS_API_KEY;      // WHY PARALLEL PROCESSING:      // ========================      // All services can work simultaneously      // Faster total processing time      // Better user experience      // Cost-effective resource usage      const services: AudioProcessor[] = [];      if (openaiKey) {        services.push(new WhisperProcessor({ apiKey: openaiKey }));      } else {      }      if (assemblyKey) {        services.push(new AssemblyAIProcessor({ apiKey: assemblyKey }));      } else {      }      if (geminiKey) {        services.push(new GeminiService());      } else {      }      if (deepgramKey) {        services.push(new DeepgramProcessor({ apiKey: deepgramKey }));      } else {      }      if (elevenlabsKey) {        services.push(new ElevenLabsProcessor({ apiKey: elevenlabsKey }));      } else {      }      if (services.length === 0) {        return {          success: false,          error: 'No AI services configured. Please set up API keys in environment variables.',        };      }      // WHY PROMISE.ALLSETTLED:      // =======================      // Some services might fail, but we want results from others      // Graceful degradation - better than complete failure      // Can still provide consensus from partial results      const processingStartTime = Date.now();      const results = await Promise.allSettled(        services.map(async service => {          try {            return await withTimeout(              service.processFile(audioFile),              TIMEOUT_CONFIG.serviceTimeoutMs,              service.serviceName            );          } catch (error) {            // WHY FALLBACK RESULT:            // ====================            // Return failed result instead of throwing            // Allows consensus algorithm to work with partial results            // Provides debugging information            return {              id: `${service.serviceName.toLowerCase()}-failed-${Date.now()}`,              serviceName: service.serviceName,              text: '',              confidence: 0,              processingTimeMs: Date.now() - processingStartTime,              timestamp: new Date(),              metadata: {                error: error instanceof Error ? error.message : 'Unknown error',              },            } as TranscriptionResult;          }        })      );      // Extract actual results from Promise.allSettled      const transcriptionResults = results.map((result, index) => {        if (result.status === 'fulfilled') {          return result.value;        } else {          return {            id: `${services[index].serviceName.toLowerCase()}-error-${Date.now()}`,            serviceName: services[index].serviceName,            text: '',            confidence: 0,            processingTimeMs: 0,            timestamp: new Date(),            metadata: { error: 'Service completely failed' },          } as TranscriptionResult;        }      });      // WHY CONSENSUS CALCULATION:      // ==========================      // Multiple AI services provide different perspectives      // Consensus algorithm finds the most accurate transcription      // Provides confidence metrics and agreement analysis      const consensus = calculateConsensus(transcriptionResults);      const totalProcessingTime = Date.now() - processingStartTime;      // WHY COMPREHENSIVE RESPONSE:      // ============================      // Provide all information needed for UI display      // Include debugging information for development      // Support future features like result comparison      return {        success: true,        consensus: consensus.consensus,        allResults: transcriptionResults,        agreementPercentage: consensus.agreementPercentage,        totalProcessingTimeMs: totalProcessingTime,        servicesUsed: services.length,        fileInfo: {          name: audioFile.name,          size: audioFile.size,          type: audioFile.type,        },      };    } catch (error) {      // WHY COMPREHENSIVE ERROR HANDLING:      // ==================================      // Server errors should be informative      // Guide regeneration when issues occur      // Don't expose sensitive information      const errorMessage = error instanceof Error ? error.message : 'Unknown server error';      return {        success: false,        error: `Server error: ${errorMessage}. Please try again or contact support.`,      };    }  },};// ========= REGENERATION BOUNDARY END: Form Actions =========/** * ============================================================================= * CONTRACT COMPLIANCE VERIFICATION * ============================================================================= * * This server implementation guarantees: * ✅ SvelteKit Actions compliance - proper form handling * ✅ Multi-AI orchestration - parallel processing of all services * ✅ Consensus algorithm integration - intelligent result combination * ✅ Comprehensive error handling - graceful failure with guidance * ✅ Security-first approach - server-side API key management * ✅ Performance optimization - parallel processing and early validation * * REGENERATION CHECKLIST: * ======================= * When regenerating this file, ensure: * 1. Actions interface is still implemented correctly * 2. All AI services are properly initialized and called * 3. Consensus algorithm provides meaningful results * 4. Error messages guide regeneration efforts * 5. Security practices are maintained * 6. Performance optimizations are preserved */
